generator client {
  provider = "prisma-client-js"
}

model Challenge {
  id        String   @id @default(cuid())
  roomId    String
  room      Room     @relation(fields: [roomId], references: [id])
  roundId   String?
  round     Round?   @relation(fields: [roundId], references: [id])
  type      String   // e.g., 'arkanoid'
  status    String   // 'ACTIVE' | 'ENDED'
  startedAt DateTime?
  endedAt   DateTime?
  config    String   @default("{}") // JSON string with { chillMode: bool, ... }
  alive     String   @default("[]") // JSON array of clerkIds still alive
  results   String   @default("{}") // JSON map clerkId -> { eliminatedAt, bricks, score }
  bets      String   @default("{}") // JSON map clerkId -> { allIn: bool, currentScore: number }
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id         String   @id @default(cuid())
  clerkId    String   @unique
  username   String   @unique
  avatarKey  String   @unique
  score      Int      @default(0)
  createdAt  DateTime @default(now())
  filmSynopsis String? // User's custom film story with their actors
  presses    Press[]
  roomMemberships RoomMembership[]
  sentMessages Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")
  messageReads MessageRead[] // Messages this user has read
  sentPokes Poke[] @relation("SentPokes")
  receivedPokes Poke[] @relation("ReceivedPokes")
  trophyWins TrophyWin[]
  players    UserPlayer[] // Players owned by this user
  team       UserTeam? // User's starting eleven
}

model Room {
  id          String   @id @default(cuid())
  name        String
  code        String   @unique // Room code for users to join
  status      RoomStatus @default(WAITING) // WAITING | ACTIVE | ENDED
  createdAt   DateTime @default(now())
  competitions Competition[]
  memberships RoomMembership[]
  messages    Message[]
  pokes       Poke[]
  challenges  Challenge[]
}

model RoomMembership {
  id        String   @id @default(cuid())
  roomId    String
  userId    String
  joinedAt  DateTime @default(now())
  
  room      Room     @relation(fields: [roomId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
  
  @@unique([roomId, userId])
}

model Competition {
  id         String   @id @default(cuid())
  roomId     String
  name       String
  status     CompetitionStatus @default(DRAFT)
  createdAt  DateTime @default(now())
  festivalPosterEnabled Boolean @default(false)
  rounds     Round[]
  questionUsages QuestionUsage[]
  categoryGames CategoryGame[]
  room       Room     @relation(fields: [roomId], references: [id])
}

enum RoomStatus {
  WAITING
  ACTIVE
  ENDED
}

model Round {
  id             String   @id @default(cuid())
  competitionId  String
  competition    Competition @relation(fields: [competitionId], references: [id])
  startedAt      DateTime?
  endedAt        DateTime?
  buttonsEnabled Boolean   @default(false)
  winnerUserId   String?
  hasTimer       Boolean  @default(false)
  timerDuration  Int?     // Duration in seconds
  timerEndsAt    DateTime? // When the timer will end
  trophyId       String?   // Trophy for this round
  trophy         Trophy?   @relation(fields: [trophyId], references: [id])
  playerTrophyId String?   // Player/Artist trophy ID (format: player_<playerId>)
  presses        Press[]
  thumbGameActive Boolean @default(false) // Is thumb game active
  thumbGameStarterId String? // User who started the thumb game
  thumbGameResponders String @default("[]") // JSON array of userIds who responded
  thumbGameUsedBy String @default("[]") // JSON array of userIds who already started thumb game this round
  challenges     Challenge[]
}

model Press {
  id        String   @id @default(cuid())
  roundId   String
  userId    String
  pressedAt DateTime @default(now())
  timerExpiresAt DateTime? // When this press's timer expires

  round     Round    @relation(fields: [roundId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([roundId, userId])
}

enum CompetitionStatus {
  DRAFT
  ACTIVE
  ENDED
}

model Question {
  id             String         @id @default(cuid())
  text           String
  type           QuestionType   @default(FREETEXT)
  imageUrl       String?        // Optional image for the question
  options        String?        // JSON string for multiple choice options
  correctAnswer  String         // For multiple choice: the correct option index/letter
  points         Int            @default(1)
  scoringType    ScoringType    @default(ALL_EQUAL)
  createdAt      DateTime       @default(now())
  answers        Answer[]
  usages         QuestionUsage[] // Track where this question has been used
}

// Tracks when a question is used in a competition
model QuestionUsage {
  id             String         @id @default(cuid())
  questionId     String
  competitionId  String
  roundId        String?
  status         QuestionStatus @default(DRAFT)
  sentAt         DateTime?      // When the question was sent to users
  completedAt    DateTime?      // When the question was completed/graded
  createdAt      DateTime       @default(now())
  trophyId       String?        // Trophy for this question
  playerTrophyId String?        // Player/Artist trophy ID (format: player_<playerId>)
  
  question       Question       @relation(fields: [questionId], references: [id])
  competition    Competition    @relation(fields: [competitionId], references: [id])
  trophy         Trophy?        @relation(fields: [trophyId], references: [id])
  
  @@unique([questionId, competitionId])
}

model Answer {
  id         String   @id @default(cuid())
  questionId String
  competitionId String  // Track which competition this answer is for
  userId     String
  text       String
  normalized String
  isCorrect  Boolean  @default(false)
  points     Int      @default(0)
  reviewed   Boolean  @default(false)
  answeredAt DateTime @default(now())
  reviewedAt DateTime?
  
  question   Question @relation(fields: [questionId], references: [id])
  
  @@unique([questionId, competitionId, userId])
}

enum QuestionType {
  FREETEXT
  MULTIPLE_CHOICE
}

enum ScoringType {
  FIRST_ONLY      // Only first correct answer gets points
  DESCENDING      // Descending points (1st gets most, last gets least)
  ALL_EQUAL       // All correct answers get the same points
}

enum QuestionStatus {
  DRAFT           // Question created but not sent
  ACTIVE          // Question sent to users, awaiting answers
  COMPLETED       // Question graded and completed
}

// Chat messages
model Message {
  id            String        @id @default(cuid())
  roomId        String
  senderId      String
  receiverId    String?       // null means message to all (group chat)
  content       String
  createdAt     DateTime      @default(now())
  read          Boolean       @default(false) // Only for DMs now
  
  room          Room          @relation(fields: [roomId], references: [id])
  sender        User          @relation("SentMessages", fields: [senderId], references: [id])
  receiver      User?         @relation("ReceivedMessages", fields: [receiverId], references: [id])
  readBy        MessageRead[] // Track who has read this message (for group messages)
  
  @@index([roomId])
  @@index([senderId])
  @@index([receiverId])
}

// Track who has read which message (for group messages)
model MessageRead {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId]) // A user can only read a message once
  @@index([userId])
  @@index([messageId])
}

// Pokes
model Poke {
  id            String   @id @default(cuid())
  roomId        String
  senderId      String
  receiverId    String
  createdAt     DateTime @default(now())
  seen          Boolean  @default(false)
  
  room          Room     @relation(fields: [roomId], references: [id])
  sender        User     @relation("SentPokes", fields: [senderId], references: [id])
  receiver      User     @relation("ReceivedPokes", fields: [receiverId], references: [id])
}

// Category Game
model CategoryGame {
  id              String           @id @default(cuid())
  competitionId   String
  categoryName    String           // Name of the category
  timePerPlayer   Int              // Time in seconds per player
  winnerPoints    Int              // Points for the winner
  turnOrder       String           // JSON array of userId in order
  currentTurnIndex Int             @default(0)
  currentPlayerId String?          // Who is currently active
  status          CategoryGameStatus @default(ACTIVE)
  isPaused        Boolean          @default(false)
  timerStartedAt  DateTime?        // When current turn timer started
  timerPausedAt   DateTime?        // When timer was paused (null if not paused)
  pausedTimeElapsed Int            @default(0) // Seconds elapsed when paused
  eliminatedPlayers String         @default("[]") // JSON array of eliminated userIds
  winnerId        String?          // Winner's userId
  createdAt       DateTime         @default(now())
  startedAt       DateTime?
  completedAt     DateTime?
  trophyId        String?          // Trophy for this game
  playerTrophyId  String?          // Player/Artist trophy ID (format: player_<playerId>)
  
  competition     Competition      @relation(fields: [competitionId], references: [id])
  trophy          Trophy?          @relation(fields: [trophyId], references: [id])
}

enum CategoryGameStatus {
  ACTIVE
  PAUSED
  COMPLETED
}

// Trophy
model Trophy {
  id          String   @id @default(cuid())
  name        String   // Display name of trophy
  imageKey    String   // Filename in /public/trophys/
  description String?  // Optional description
  createdAt   DateTime @default(now())
  
  rounds      Round[]
  questions   QuestionUsage[]
  categoryGames CategoryGame[]
  wins        TrophyWin[]
}

// Trophy Wins - tracks when users win trophies
model TrophyWin {
  id          String   @id @default(cuid())
  userId      String
  trophyId    String
  wonAt       DateTime @default(now())
  source      String   // "round", "question", or "category"
  sourceId    String   // ID of the round, question, or category game
  
  user        User     @relation(fields: [userId], references: [id])
  trophy      Trophy   @relation(fields: [trophyId], references: [id])
  
  @@index([userId])
  @@index([trophyId])
}

// Player - represents football players and other awards
model Player {
  id          String   @id @default(cuid())
  name        String   // Display name
  position    PlayerPosition // GK, DEF, MID, FWD (only for footballer type)
  imageKey    String   // Filename in /public/starting_pack/ or /public/footballers/
  type        PlayerType @default(FOOTBALLER) // FOOTBALLER, FESTIVAL, FILM
  category    PlayerCategory // STARTER or AWARD
  createdAt   DateTime @default(now())
  
  userPlayers UserPlayer[] // Players owned by users
  teamPositions TeamPosition[] // Positions in user teams
}

enum PlayerPosition {
  GK   // Goalkeeper
  DEF  // Defender
  MID  // Midfielder
  FWD  // Forward
  ANY  // For non-footballer awards
}

enum PlayerType {
  FOOTBALLER
  FESTIVAL
  FILM
  ACTOR
}

enum PlayerCategory {
  STARTER  // Starting pack
  AWARD    // Won during game
  CAPTAIN  // User's captain based on avatar
}

// UserPlayer - junction table for players owned by users
model UserPlayer {
  id        String   @id @default(cuid())
  userId    String
  playerId  String
  acquiredAt DateTime @default(now())
  revealed  Boolean  @default(false) // For festival artists - has user flipped the card?
  
  user      User     @relation(fields: [userId], references: [id])
  player    Player   @relation(fields: [playerId], references: [id])
  
  @@unique([userId, playerId])
  @@index([userId])
  @@index([playerId])
}

// UserTeam - stores user's current formation and lineup
model UserTeam {
  id          String   @id @default(cuid())
  userId      String   @unique
  formation   Formation @default(F442)
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id])
  positions   TeamPosition[]
}

enum Formation {
  F442         // 4-4-2
  F442_DIAMOND // 4-4-2 Diamond
  F433         // 4-3-3
  F343         // 3-4-3
}

// TeamPosition - individual position in user's team
model TeamPosition {
  id        String   @id @default(cuid())
  teamId    String
  playerId  String
  position  Int      // Position index (0-10) for the 11 players
  
  team      UserTeam @relation(fields: [teamId], references: [id], onDelete: Cascade)
  player    Player   @relation(fields: [playerId], references: [id])
  
  @@unique([teamId, position])
  @@index([teamId])
  @@index([playerId])
}
